<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PINN</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
  <div class="container mx-auto p-6">
    <header class="mb-6">
      <a href="../index.html" class="text-blue-600 hover:underline">Back to Main</a>
      <h1 class="text-3xl font-bold mt-2">PINN</h1>
      <h2 class="text-xl text-gray-600">Physics-Informed Neural Network</h2>
    </header>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Inverse Modeling Neural Network with Physics-Informed Loss</h3>
      <p class="text-gray-700">
        This approach combines data-driven learning with physics-based
        modeling to infer key physical parameters from observed data. The
        goal is to develop a neural network–physics hybrid model that
        enables inverse modeling of dynamic systems, using simulation
        constraints to ensure physically meaningful predictions. This
        framework is especially relevant for applications such as
        reduced-order modeling (ROM) in biomedical systems, e.g.,
        predicting the progression of arterial occlusion from noninvasive
        measurements like tissue oxygenation.
      </p>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Purpose</h3>
      <p class="text-gray-700">
        The primary objective is to infer hidden physical parameters—such
        as diffusivity and source strength in a heat conduction model—by
        comparing simulated outputs driven by learned parameters to noisy
        observed data. Unlike traditional forward models, which predict
        system behavior from known parameters, inverse modeling solves the
        harder problem of recovering the parameters themselves.
      </p>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Advantages</h3>
      <ul class="list-disc pl-6 text-gray-700">
        <li><strong>End-to-End Differentiability</strong>: The entire model,
          including the physics solver, is differentiable, enabling
          gradient-based training.</li>
        <li><strong>Physical Interpretability</strong>: The learned
          features correspond to meaningful physical quantities.</li>
        <li><strong>Simulation-Consistent Learning</strong>: The model
          respects the underlying physics throughout the learning
          process.</li>
        <li><strong>Efficiency</strong>: The model learns a reduced
          representation of a full simulation, offering potential speed-ups
          during deployment.</li>
      </ul>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Feasibility and Precedents</h3>
      <p class="text-gray-700">
        This methodology is well-supported by existing literature in
        scientific machine learning. Similar hybrid and physics-informed
        frameworks have been applied successfully in fields like
        aerospace, fluid mechanics, and structural dynamics (e.g., Journal
        of Fluids and Structures, 2017; ERCOFTAC workshops, 2025). These
        precedents validate both the theoretical soundness and practical
        relevance of embedding physical constraints into learning
        pipelines, especially when data are limited and interpretability is
        critical.
      </p>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Case 1 — Inverse modeling a 1D heat conduction system with fixed parameters</h3>
      <h4 class="text-xl font-semibold mb-2">Code implementation 1</h4>
      <ul class="list-disc pl-6 text-gray-700">
        <li><strong>Heat Equation</strong>: \( \frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2} + \beta \sin(\pi x) \)</li>
        <li><strong>Analytical Solution</strong>:
          \[
          u(x, t) = \sin(\pi x) \left[ e^{-\pi^2 \alpha t} + \frac{\beta}{\pi^2 \alpha}(1 - e^{-\pi^2 \alpha t}) \right]
          \]
        </li>
        <li><strong>Numerical Solver</strong>: Crank–Nicolson scheme is
          used for time-stepping the PDE numerically in a differentiable
          manner.</li>
        <li><strong>Neural Network</strong>: Maps noisy field
          \(u(x, t)\) to \((\alpha, \beta) \in (0, 1)^2\) using a
          two-layer MLP.</li>
        <li><strong>Loss</strong>: \(\mathcal{L} = \| u_{\text{pred}} - u_{\text{true}} \|^2\), ensuring that learned parameters replicate the observed dynamics.</li>
      </ul>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Case 2 — Inverse modeling a 1D advection–diffusion system with fixed parameters</h3>
      <h4 class="text-xl font-semibold mb-2">Code implementation 2</h4>
      <ul class="list-disc pl-6 text-gray-700">
        <li><strong>Advection–Diffusion Equation</strong>: \( \frac{\partial u}{\partial t} + v \frac{\partial u}{\partial x} = \alpha \frac{\partial^2 u}{\partial x^2} \)</li>
        <li><strong>Analytical Solution</strong>:
          \[
          u(x,t) = \frac{1}{\sqrt{4\pi \alpha t}} \exp\left(-\frac{(x - vt - 0.5)^2}{4\alpha t}\right)
          \]
        </li>
        <li><strong>Numerical Solver</strong>: Implicit finite difference
          scheme handling both advection and diffusion; inlet conditions
          are defined by the analytical solution.</li>
        <li><strong>Neural Network</strong>: Learns to predict
          \((\alpha, v) \in (0,1)^2\) from noisy snapshots of \(u(x,t)\).</li>
        <li><strong>Loss</strong>: \(\mathcal{L} = \| u_{\text{pred}} - u_{\text{true}} \|^2\), ensuring physics-consistent parameter recovery.</li>
      </ul>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Case 3 — Inverse modeling a 1D advection–diffusion–reaction system with fixed parameters</h3>
      <h4 class="text-xl font-semibold mb-2">Code implementation 3</h4>
      <ul class="list-disc pl-6 text-gray-700">
        <li><strong>Advection–Diffusion–Reaction Equation</strong>: \( \frac{\partial u}{\partial t} + v \frac{\partial u}{\partial x} = \alpha \frac{\partial^2 u}{\partial x^2} + R(u) \), where \( R(u) \) models spatially heterogeneous reaction terms.</li>
        <li><strong>Synthesized Data Samples</strong>: Noisy measurements of \( u(x,t) \) are generated by simulating the forward PDE solver with known parameters \((\alpha, v, r_0, r_1)\) at random time points. Gaussian noise is added to simulate observation uncertainty.</li>
        <li><strong>Numerical Solver</strong>: Implicit finite difference scheme that handles all three processes—advection, diffusion, and spatially varying reactions—implemented as a differentiable module for backpropagation.</li>
        <li><strong>Neural Network</strong>: Maps input pairs of noisy solution fields and time into predicted parameters \((\alpha, v, r_0, r_1)\), using a two-layer MLP with bounded sigmoid output scaled to physical ranges.</li>
        <li><strong>Loss</strong>: \(\mathcal{L} = \| u_{\text{pred}} - u_{\text{true}} \|^2\), comparing simulated outputs under predicted parameters to noisy observations, enabling inverse inference.</li>
      </ul>
    </section>

    <section class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h3 class="text-2xl font-semibold mb-4">Case 4 — Inverse modeling a 1D hemodynamic system</h3>
      <h4 class="text-xl font-semibold mb-2">Code implementation 4</h4>
      <ul class="list-disc pl-6 text-gray-700">
        <li><strong>Governing Equations</strong>: The 1D hemodynamics model describes blood flow in a vessel, solving for flow rate \( Q(x,t) \) and cross-sectional area \( A(x,t) \):
          <ul class="list-none pl-4">
            <li><strong>Conservation of Mass</strong>: \( \frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0 \)</li>
            <li><strong>Conservation of Momentum</strong>: \( \frac{\partial Q}{\partial t} + \frac{\partial}{\partial x} \left( \alpha \frac{Q^2}{A} \right) + \frac{A}{\rho} \frac{\partial P}{\partial x} = -K_R \frac{Q}{A} \)</li>
            <li><strong>Constitutive Relation</strong>: Pressure is related to area via \( P = P_0 + \beta \left( \sqrt{A} - \sqrt{A_0} \right) \), where \( \rho \) is blood density, \( \alpha \) is the momentum correction factor, \( K_R \) is the friction parameter, \( \beta \) is the vessel stiffness, \( A_0 \) is the reference area, and \( P_0 \) is the reference pressure.</li>
          </ul>
        </li>
        <li><strong>Boundary Conditions</strong>:
          <ul class="list-none pl-4">
            <li><strong>Inlet</strong>: Both \( Q(t) \) and \( P(t) \) are prescribed, as \( A(t) \) is not typically measurable. \( P(t) \) determines \( A(t) \) via the constitutive relation.</li>
            <li><strong>Outlet</strong>: \( P(t) \) is prescribed, and \( Q(t) \) is inferred using a model (e.g., resistance, RCR, or impedance), such as \( P(t) = R Q(t) \) for a resistance boundary condition.</li>
          </ul>
        </li>
      </ul>
    </section>

    <footer class="text-center text-gray-600 mt-6">
      <p>© 2025 Zhenwen Wan. All rights reserved.</p>
    </footer>
  </div>
</body>
</html>